## Hooks

# case-insensitive search
map global user s '/(?i)'

# add line numbers
hook global WinCreate .* %{addhl number_lines}
# highlight characters in 81st column
hook global WinCreate .* %{addhl regex ^\V{80}(\V) 1:Error}

# add brackets highlighting
hook global WinCreate .* %{addhl show_matching}

# scroll offset
set global scrolloff 12,0

# tabs
## 4-space tabs
set global indentwidth 4
set global tabstop 4
## 2-space tabs for Haskell
hook global BufSetOption filetype=haskell %{
    set buffer tabstop 2
    set buffer indentwidth 2
}
## soft tabs (excluding makefiles and Go)
hook global BufSetOption filetype=(?!(makefile)|(go)).*? %{
    hook buffer InsertChar \t %{ exec -draft -itersel h@ }
}

hook global InsertKey <backspace> %{ try %{
  exec -draft hGh<a-k>\A\h+\Z<ret>gihyp<lt>
}}

hook global BufCreate .*[.](ts|tsx|html) %{
    set buffer tabstop 2
    set buffer indentwidth 2
}

map global user f '/%opt{function_start}<a-n>?%opt{function_end}<ret>'

# auto wrap at 80 chars
set global autowrap_column 80
hook global WinCreate .* %{ autowrap-enable }

# colors
colorscheme solarized2

# Tmux integration
# ================

def tmux-new %{
    on-key %{ %sh{
        case "$kak_key" in
            \\) echo tmux-new-horizontal ;;
            "<minus>") echo tmux-new-vertical ;;
        esac
    } }
}
map global user t :tmux-new<ret>

def repl-send %{
    on-key %{ %sh{
        case "$kak_key" in
            's') echo 'send-text' ;;
            'l') echo 'exec hxH:send-text<ret>;exec ";"<ret>' ;;
        esac
    } }
}
map global user r :repl-send<ret>

# Git
# ===

hook global WinSetOption filetype=diff %{
    map window normal '@' /^@@<ret>
    map window normal '#' /^diff\><ret>
}

# X11 (copy/paste)
# ===============
map global user y 'y<a-|>xclip -i<ret>; :echo -color Information "copied
 selection to X11 clipboard"<ret>'
map global user p '!xclip -o <ret>'

# commenting
def comment %{
    on-key %{ %sh{
        case "$kak_key" in
            'c') echo comment-line ;;
            'b') echo 'exec <a-i>pH:comment-block<ret>' ;;
        esac
    } }
}
map global user c :comment<ret>

# Haskell
# =======

# Typescript
# ==========

# html tags
hook global BufSetOption filetype=typescript %{
    map global user h 'i<lt><gt><lt>/<gt><esc>hh/<gt><ret>HHHHs<lt>/?<ret>\'a'
}

# Markdown manipulation
# =====================

hook global BufSetOption filetype=markdown %{
    #def build %{
        #on-key %{ %sh{
            #case "$kak_key" in
                #'d') echo 'nop "%sh{ alias_call md latex ${kak_buffile}  }" <ret>' ;;
                #'b') echo 'nop "%sh{ alias_call md beamer ${kak_buffile}  }" <ret>' ;;
            #esac
        #} }
    #}
    #map global user b :build<ret>

    # build document
    map global user w %{ :nop "%sh{ alias_call md beamer ${kak_buffile}  }" <ret> }

    # format text with pandoc
    map global user g %{ | pandoc --from=markdown --to=markdown --columns=80 <ret> }

    # custom commands
    def header %{
        on-key %{ %sh{
            case "$kak_key" in
                '1') echo 'exec hxypjxHr=A<ret><esc>' ;;
                '2') echo 'exec hxypjxHr-A<ret><esc>' ;;
                '3') echo 'exec I###<space><esc>A<ret><esc>' ;;
            esac
        } }
    }
    map global user h :header<ret>
    #map global user b %{ | pandoc-citeproc --bib2yaml --format=biblatex <ret> }

    def inline_code_helper %{ exec ',ea`f`a{.}<esc>;i' }
    def inline_code %{
        on-key %{ %sh{
            case "$kak_key" in
                'i') echo inline_code_helper ;;
                'r') echo 'inline_code_helper;exec ruby<esc><ret>' ;;
            esac
        } }
    }
    map global user i :inline_code<ret>
}

def add-surround %!on-key %@exec %sh&
  case "$kak_key" in
      "<lt>") key="<" ;;
      "<gt>") key=">" ;;
      "<space>") key=" " ;;
      \<*\>) echo ":echo<space>no<ret>"; exit 1 ;;
      *) key="$kak_key" ;;
  esac

  open="$key"
  close="$key"
  case "$key" in
      "("|")") open="("; close=")" ;;
      "["|"]") open="["; close="]" ;;
      "{"|"}") open="{"; close="}" ;;
      "<"|">") open="<"; close=">" ;;
  esac

  epilogue=${close//?/H}

  open=${open/</<lt>}
  close=${close/>/<gt>}

  open=${open/ /<space>}
  close=${close/ /<space>}
  
  echo "i$open<esc>a$close<esc>$epilogue"
&@!

def delete-surround %!on-key %@exec %sh&
  case "$kak_key" in
      "<lt>") key="<" ;;
      "<gt>") key=">" ;;
      "<space>") key=" " ;;
      \<*\>) echo ":echo<space>no<ret>"; exit 1 ;;
      "*"|"."|"?"|"\\") key="\\$kak_key" ;;
      *) key="$kak_key" ;;
  esac

  open="$key"
  close="$key"
  case "$key" in
      "("|")") open="\("; close="\)" ;;
      "["|"]") open="\["; close="\]" ;;
      "{"|"}") open="{"; close="}"   ;;
      "<"|">") open="<"; close=">"   ;;
  esac

  open=${open/</<lt>}
  close=${close/>/<gt>}

  open=${open/ /<space>}
  close=${close/ /<space>}
  
  echo "<a-a>${kak_key}s${open}|${close}<ret>d<space>"
&@!

def surround %{
    on-key %{ %sh{
        case "$kak_key" in
            a) echo add-surround
               ;;
            d) echo delete-surround
               ;;
        esac
    } }
}
map global user e ":surround<ret>"
