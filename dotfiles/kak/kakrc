# colors
colorscheme solarized2

# scroll offset
set global scrolloff 12,0

# show all trailing whispaces red
hook -group TrailingWhitespaces global WinCreate .* %{
    addhl global regex "[ \t]+$" 0:default,red
}

# add brackets highlighting
hook global WinCreate .* %{addhl global show_matching}


# tabs
# ====

# 4-space tabs
hook global InsertChar \t %{ exec -draft -itersel h@ }
set global indentwidth 4
set global tabstop 4

## 2-space tabs for Haskell
hook global BufSetOption filetype=haskell %{
    set buffer tabstop 2
    set buffer indentwidth 2
}

# backspace full tab width
map global insert <backspace> ⌫
hook global InsertChar ⌫ %{ try %{
    execute-keys <backspace>
    try %{
        execute-keys -draft hGh <a-k>\A\h+\z<ret> <lt>
    } catch %{
        execute-keys <backspace>
    }
} }

# tab completion and indentation
hook global InsertCompletionShow .* %{
    try %{
        # this command temporarily removes cursors preceded by whitespace;
        # if there are no cursors left, it raises an error, does not
        # continue to execute the mapping commands, and the error is eaten
        # by the `try` command so no warning appears.
        execute-keys -draft 'h<a-K>\h<ret>'
        map window insert <tab> <c-n>
        map window insert <s-tab> <c-p>
    }
}
hook global InsertCompletionHide .* %{
    unmap window insert <tab> <c-n>
    unmap window insert <s-tab> <c-p>
}


# Tmux integration
# ================

def tmux-new %{
    on-key %{ %sh{
        case "$kak_key" in
            \\) echo tmux-new-horizontal ;;
            "<minus>") echo tmux-new-vertical ;;
        esac
    } }
}
map global user t :tmux-new<ret> -docstring 'new tmux'

def repl-send %{
    on-key %{ %sh{
        case "$kak_key" in
            's') echo 'send-text' ;;
            'l') echo 'exec hxH:send-text<ret>;exec ";"<ret>' ;;
        esac
    } }
}
map global user r :repl-send<ret> -docstring 'tmux send ret'


# Git
# ===

hook global WinSetOption filetype=diff %{
    map window normal '@' /^@@<ret>
    map window normal '#' /^diff\><ret>
}


# custom commands
# ===============

# X11 copy paste
map global user y 'y<a-|>xclip -i<ret>' -docstring 'yank to X11'
map global user p '!xclip -o<ret>' -docstring 'paste from X11'
# align equals signs
map global user a '<a-i>ps=<ret>&<space>gl' -docstring 'align ='
# non inset mode backspace and return
# case-insensitive search
map global user / '/(?i)' -docstring 'caseless search'
map global user s 's(?i)' -docstring 'caseless selection'
map global user S 'S(?i)' -docstring 'caseless split'
# normal mode comands
map global normal <ret> 'i<ret><esc>'
map global normal <backspace> 'i<backspace><esc>'
# jump paragraph
map global normal <a-j> '<a-a>pgh'
map global normal <a-k> '<a-a>p<a-;>kk'

# toggle spell check
def toggle-spell %{
    try %{
        addhl window ranges 'spell_regions'
        spell
        } catch %{ rmhl window/hlranges_spell_regions }
}
map global user <a-s> :toggle-spell<ret> -docstring 'toggle spell check'

# add line numbers
hook global WinCreate .* %{addhl global number_lines -relative
}

# commenting
def comment %{
    on-key %{ %sh{
        case "$kak_key" in
            'c') echo comment-line ;;
            'b') echo 'exec <a-i>pH:comment-block<ret>' ;;
            'g') echo 'set buffer filetype go;comment-line;set buffer filetype markdown' ;;
        esac
    } }
}
map global user c :comment<ret> -docstring 'commenting'

# commented headers
def header %{
    on-key %{ %sh{
        case "$kak_key" in
            '1') echo comment-line; echo 'exec hxypjxHr=A<ret><esc>kr#lr<space>j';;
            '2') echo comment-line; echo 'exec hxypjxHr-A<ret><esc>kr#lr<space>j';;
            '3') echo comment-line; echo 'exec I##<esc>A<ret><esc>hd' ;;
        esac
    } }
}
map global user h :header<ret> -docstring 'headers'


# Markdown specific commands
hook global BufSetOption filetype=(markdown) %{
    # headers
    def header %{
        on-key %{ %sh{
            case "$kak_key" in
                '1') echo 'exec hxypjxHr=A<ret><esc>' ;;
                '2') echo 'exec hxypjxHr-A<ret><esc>' ;;
                '3') echo 'exec I###<space><esc>A<ret><esc>' ;;
            esac
        } }
    }
map global user h :header<ret> -docstring 'headers'
}


# edit surrounding
# ================

def add-surround %!on-key %@exec %sh&
  case "$kak_key" in
      "<lt>") key="<" ;;
      "<gt>") key=">" ;;
      "<space>") key=" " ;;
      \<*\>) echo ":echo<space>no<ret>"; exit 1 ;;
      *) key="$kak_key" ;;
  esac

  open="$key"
  close="$key"
  case "$key" in
      "("|")") open="("; close=")" ;;
      "["|"]") open="["; close="]" ;;
      "{"|"}") open="{"; close="}" ;;
      "<"|">") open="<"; close=">" ;;
  esac

  epilogue=${close//?/H}
  open=${open/</<lt>}
  close=${close/>/<gt>}
  open=${open/ /<space>}
  close=${close/ /<space>}
  echo "i$open<esc>a$close<esc>$epilogue"
&@!

def delete-surround %!on-key %@exec %sh&
  case "$kak_key" in
      "<lt>") key="<" ;;
      "<gt>") key=">" ;;
      "<space>") key=" " ;;
      \<*\>) echo ":echo<space>no<ret>"; exit 1 ;;
      "*"|"."|"?"|"\\") key="\\$kak_key" ;;
      *) key="$kak_key" ;;
  esac

  open="$key"
  close="$key"
  case "$key" in
      "("|")") open="\("; close="\)" ;;
      "["|"]") open="\["; close="\]" ;;
      "{"|"}") open="{"; close="}"   ;;
      "<"|">") open="<"; close=">"   ;;
  esac

  open=${open/</<lt>}
  close=${close/>/<gt>}
  open=${open/ /<space>}
  close=${close/ /<space>}
  echo "<a-a>${kak_key}s${open}|${close}<ret>d<space>"
&@!

def surround %{
    on-key %{ %sh{
        case "$kak_key" in
            a) echo add-surround
               ;;
            d) echo delete-surround
               ;;
        esac
    } }
}
map global user e ":surround<ret>" -docstring 'edit surrounding'
