# Shortcuts
# TEMPORARY: not sure where to put these
export VENVS="$HOME/.venv"
export DIRSTORE="$HOME/.dirstore"


ipfs() {
    case "$1" in
        'public')      config='--config ~/.ipfs'
                       shift
                       ;;
        'p'|'private') config='--config ~/.ipfs-private'
                       shift
                       ;;
        *)             config=''
                       ;;
    esac

    eval /usr/bin/ipfs "$config" $@
}

playlist_get() {
    [[ -z "$1" ]] && return 1
    playlist_hash="$1"
    is_first_line=true
    IFS=$'\n'
    for line in `ipfs private cat "$playlist_hash"`; do
        if [[ "$is_first_line" = true ]]; then
            playlist_name="$line"
            playlist_dir="$MUSIC/playlists/$playlist_name"
            playlist_file="$playlist_dir/playlist.pl"
            mkdir "$playlist_dir"
            rm -f "$playlist_file" && touch "$playlist_file"
            is_first_line=false
            continue
        fi
        song_map=("${(@s/ /)line}")
        ipfs private pin add "/ipfs/$song_map[1]"
        ln -sf "/ipfs/$song_map[1]" "$playlist_dir/$song_map[2]"
        echo "$playlist_dir/$song_map[2]" >> "$playlist_file"
   done
}


playlist_menu() {

    #playlists_global=($(awk '{print $1}' =(echo $playlist_index)))
    #playlists_hash=($(awk '{print $2}' =(echo $playlist_index)))
    #playlist_options=(`echo ${playlists_local[@]} ${playlists_global[@]} | \
    #    tr ' ' '\n' | sort | uniq -u `)
    #echo ${playlists_hash[1]}



    playlist_index=$(ipfs private cat \
        /ipns/QmYzX4jvZT2iUDPVdG1MCJ8bX5Q2pca66QsPgDYWU4mUGZ)
    playlists_local=($(ls $MUSIC/playlists))
    counter=0
    typeset -A playlist_hash
    IFS=$'\n'
    for pl_index in `echo $playlist_index`; do
        pl_name=$(awk '{print $1}' =(echo $pl_index))
        pl_hash=$(awk '{print $2}' =(echo $pl_index))
        exists=false
        for pl_local in $playlists_local; do
            if [[ "$pl_local" == "$pl_name" ]]; then
                exists=true
                break
            fi
        done
        if [[ "$exists" == false ]]; then
                echo "$counter: $pl_name"
                counter="$(($counter + 1))"
                playlist_hash[$counter]=$pl_hash
        fi
    done

    printf "Which playlist: "
    read playlist_num
    if [[ "$playlist_num" -lt '0' || "$playlist_num" -gt "${#playlists}" ]]; then
        echo "Out of range."
        return 1
    fi

    playlist_get "${playlist_hash[$(($playlist_num+1))]}"
}


playlist_add() {
    [[ -z "$1" ]] && return 1
    playlist="$1"
    playlist_name="${playlist%.*}"
    rm -f /tmp/pl && touch /tmp/pl
    i=1
    for song in `cat "$playlist"`; do
        hash=$(ipfs private add -q "$song")
        song_name=$(sed 's/^[0-9]_[0-9]\+-//' =(echo "${song:t}"))
        song_pl=$(printf "$playlist_name/%02d-$song_name" $i)
        ((i = i + 1))
        echo "$hash $song_pl" >> /tmp/pl
    done
    ipfs private add -Q /tmp/pl
}


# log into Sensory vpn and ssh into ears
# --------------------------------------
ssh_ears() {
    sudo pon sensory
    sleep 8
    sudo ip route add 10.10.0.0/16 dev ppp0
    ssh ears

}

vpn_sns() {
    sudo pon sensory
    sleep 8
    sudo ip route add 10.10.0.0/16 dev ppp0
}

vpn_off() {
    sudo poff
}


# exit terminal
alias x='exit'

# cd to bookmark
# --------------
c() {                       # cd with bookmarks
    SHORT="$1"
    DIRNAME=$(sed -n -e "s/^$SHORT) //p" "$DIRSTORE")
    cd "$DIRNAME"
    unset DIRNAME           # for dir displayed in prompt
}

# create directory bookmark
# -------------------------
s() {
    SHORT=$1
    [[ -z "$SHORT" ]] && return 1
    DIR=`pwd`
    if [[ ! -z "$2" ]] then;
        DIR="$2"
    fi
    DIRLINE="$SHORT) $DIR"
    # prepend new directory with tag to storage file
    echo "$DIRLINE"|cat - "$DIRSTORE" >! /tmp/dirline && mv -f /tmp/dirline "$DIRSTORE"
}


# create alias file
# -----------------
create_alias() {
    SHORT="$1"
    [[ -z "$SHORT" ]] && return 1
    FNAME = "$SHORT_aliases"
    DIR="$DOTFILES/zsh/alias"
    [[ -a "$DIR/$FNAME" ]] && return 1
    echo "default aliases?" > "$DIR/$FNAME"
}

# create working environment
# --------------------------
create_environment() {
    SHORT="$1"
    [[ -z "$SHORT" ]] && return 1
    DIR=`pwd`
    if [[ ! -z "$2" ]] then;
        DIR="$2"
    fi
}

# start working environment
# -------------------------
start_environment() {
    env="$1"
    [[ -z "$env" ]] && return 1
    source_alias "$env" > /dev/null
    c "$env" &> /dev/null
    case "$env" in
        sns)
            source_alias sns_aliases
            start_venv "scene"
            ;;
        dev)
            source_alias "git" > /dev/null
            ;;
    esac
}
alias se='start_environment'


# create python virtual environment
# ---------------------------------
create_venv() {
    virtual_env="$1"
    if [[ -z virtual_env ]]; then
        echo "create python vitual enviroment <pyproject> for python <version>:"
        echo "create_venv <pyproject> <version>"
#       TODO: grab the actual available versions for 2 and 3. Ensure 3.3+
        echo "<version> supports 2 (2.7) 3 (3.5)"
        return 1
    version = 3.0
    fi
    if [[ ! -z "$2" ]]; then
        version = "$2"
    fi
    pyvenv "$VENVS/$virtual_env"
}


# start python virtual environment
# --------------------------------
start_venv() {
    if [[ -z "$1" ]]; then
        echo "options:"
        ls -lh "$VENVS" | tail -n +2 | awk '{ print $9 }' | sed -e "s/\(.*\)/  - \1/"
        return 1
    fi
    virtual_env="$1"
    [[ -d "$VENVS/$virtual_env" ]] && source "$VENVS/$virtual_env/bin/activate"
}
alias sv='start_venv'


# open pdf, refresh tmux on close
# -------------------------------
pdf() {
    # note: update to check for jfbview
    # $VIEWER "$1"
    jfbview "$1"
    tmux refresh-client
}
# open pdf as plaintext
# ---------------------
tdf() {
    lesspipe.sh "$1" | less
}

# markdown publishing
md() {
    format="$1"
    md_doc="$2"

    case "$format" in
        markdown)   ext='md'                    ;;
        latex)      ext='pdf'                   ;;
        latex-raw)  ext='tex'; format='latex'   ;;
        beamer)     ext='pdf'                   ;;
        beamer-raw) ext='tex'; format='beamer'  ;;
        *)          ext="$format"               ;;
    esac

    pandoc --standalone --filter=pandoc-citeproc \
           --from=markdown --to="$format" \
           --output="${md_doc%.*}.$ext" "$md_doc" \
        || echo "pandoc error ..."
}

# latex building
# --------------
tex() {
    [[ -z "$1" ]] && return 1
    file="$1"
    prefix=${file%.*}

    pdflatex --shell-escape "$prefix".tex &&
    bibtex                  "$prefix"     &&
    pdflatex --shell-escape "$prefix".tex &&
    pdflatex --shell-escape "$prefix".tex

    rm -f $prefix.{out,snm,aux,toc,nav,lo?}
}

# cmus with lyrics and cover art
# ------------------------------
alias cf='cmus_full && exit'

# start existing vim session
# --------------------------
alias vs="vim -S"

# `vim <today's_date>.md`
# -----------------------
kt() {
    format='%Y-%m-%d'
    kak "`date +$format`.md"
}

# 'journal today'
# ---------------
jt() {
    format='%Y-%m-%d'
    journal_dir="$PERSONAL/routine/morning/journal/five_minute_journal"
    cp -n "$journal_dir/template.md" "$journal_dir/`date +$format`.md"
    cd "$journal_dir"
    kt
}

# copy etc
# --------
cp_etc() {
    dir="$1"
    [[ ! -d "$DOTFILES/etc/$dir" ]] && return 1
    for file in $(find "$DOTFILES/etc/$dir" -type f); do
        sudo cp "$file" "${file#$DOTFILES}"
    done
}

# edit alias file
# ---------------
edit_alias() {
    if [[ $# -eq 0 ]]; then
        print_aliases
        return 1
    fi
    input_arg="$1"

    case "$input_arg" in
        g|global)
            alias_file="$GLOBAL_ALIAS"
            ;;
        l|local)
            alias_file="$LOCAL_ALIAS"
            ;;
        *)
            alias_file="$ALIASES/${input_arg}_aliases"
            ;;
    esac

    "$EDITOR" "$alias_file"
}
alias ea='edit_alias'

# remove alias file
# -----------------
remove_alias() {
    if [[ $# -eq 0 ]]; then
        print_aliases
        return 1
    fi

    input_arg="$1"
    case "$input_arg" in
        '-f')
            force=true
            shift
            ;;
        *)
            force=false
            ;;
    esac

    alias_file="$ALIASES/${1}_aliases"

    [[ -f "$alias_file" ]] || return 1

    # confirm with user if 'force' flag not provided
    if [[ "$force" = false ]]; then
        echo -n "Remove $alias_file (y/n)? "
        read choice
       
        if ! echo "$choice" | grep -iq "^y"; then
            return 1
        fi
    fi

    rm -f "$alias_file"
}
alias ra='remove_alias'

# source alias file
# -----------------
source_alias() {
    # if no input, print list of possible inputs and return
    if [[ $# -eq 0 ]]; then
        print_aliases
        return 1
    fi
    # check input(s), source associated alias file(s) accordingly
    input_arg="$1"
    shift
    case "$input_arg" in
        g|global)
            alias_file="$GLOBAL_ALIAS"
            ;;
        l|local)
            alias_file="$LOCAL_ALIAS"
            ;;
        *)
            alias_file="$ALIASES/${input_arg}_aliases"
            ;;
    esac
    if [[ -f "$alias_file" ]]; then
        echo "sourcing $alias_file"
        source "$alias_file"
    fi
    [[ $# -gt 0 ]] && source_alias $@
}
alias sa='source_alias'

### print alias file options (helper for {source,edit}_alias)
print_aliases() {
        echo "options:"
        echo "  - global (g)"
        echo "  - local (l)"
        ls -lh "$ALIASES" | tail -n +2 | awk '{ print $9 }' | sed -e "s/\([^_ ]\+\)_aliases/  - \1/"
}

# general git (more in git_aliases)
# ---------------------------------
alias gc='git commit -m'
alias gca='git commit -am'
alias gco='git checkout'
alias gl="git log --pretty=format:'%C(auto)%h %ad %C(green)%s%Creset %C(auto)%d [%an]' --graph --date=format:'%Y-%m-%d %H:%M' --all"

# start working environment
# -------------------------
start_environment() {
    env="$1"
    [[ -z "$env" ]] && return 1

    source_alias "$env" > /dev/null
    c "$env" &> /dev/null
    case "$env" in
        cluster)
            source_alias 'ipfs' > /dev/null
            ;;
        web)
            source_alias 'python' > /dev/null
            flasky_aliases
            start_venv 'flask'
            ;;
        ta)
            start_venv 'ta'
            unset BROWSER
            ;;
    esac

    # show active env(s) in prompt
    if [[ -z "$WENV" ]]; then
        export WENV="$env"
        export PS1="($WENV) $PS1"
    else
    if [[ ! $WENV =~ (^|,| )${env}($|,| ) ]]; then
        export WENV="$WENV, $env"
        export PS1=$(echo "$PS1" | sed -re 's/^\(.*?\) //')
        export PS1="($WENV) $PS1"
    fi
    fi

    [[ -n "$TMUX" ]] && tmux set-environment WENV "$WENV"
}

start_environments() {
    envs=$@
    for env in $(echo "$envs" | sed -r 's/, ?/\n/g'); do
        start_environment "$env"
    done
}
alias se='start_environments'

clear_environment() {
    unset WENV
    export PS1=$(echo "$PS1" | sed -re 's/^\(.*?\) //')
}
alias ce='clear_environment'

reset_environment() {
    [[ -n "$TMUX" ]] && tmux set-environment WENV "$WENV"
}
alias re='reset_environment'

# Scheduling
# ==========

# schedule/events
# ---------------
todo() {
    stuff="$PERSONAL/schedule/daily"
    format='%Y-%m-%d'
    cat "$stuff/`date +$format`.md"
}
schedule() { sed -n '/schedule/,$p' $PERSONAL/todo.md && echo && echo }
events() { sed -n '/events/,/tasks/p' $PERSONAL/todo.md | head -n-1 }
short_term() { sed -n '/short term/,/general/p' $PERSONAL/todo.md | head -n-1 }
alias st='short_term'
assignments() {
    sed -n '/assignments/,/schedule/p' $PERSONAL/todo.md | head -n-1
}
alias ass='assignments'
alias assless='assignments | less'

# schedule today
# --------------
today() {
    day_offset="$1"
    [[ -z "$day_offset" ]] && day_offset='0'
    schedule_file="$PERSONAL/todo.md"
    day="$(date --date="$day_offset days" +%A | awk '{print tolower($0)}')"
    sed -n '/^'"$day"'$/,/^\w/p' $schedule_file | head -n -1
    dated="$(date --date="$day_offset days" +'%b %-d' | awk '{print tolower($0)}')"
    sed -n '/^'"$dated"'$/,/^\w/p' $schedule_file | head -n -1
}

# schedule for week
# -----------------
week() {
    week_offset="$1"
    [[ -z "$week_offset" ]] && week_offset='0'
    let day="$week_offset*7"
    for i in {0..6}; do
        let day="$day+$i"
        today $day
    done
}

# due today
# ---------
due_today() {
    day_offset="$1"
    [[ -z "$day_offset" ]] && day_offset='0'
    format='%m-%d'
    due_date="$(date --date="$day_offset days" +$format)"
    schedule_file="$HOME/todo.md"
    echo "$input" | grep "$due_date" | grep -v "DONE"
}

# due within the week
# -------------------
due_week() {
    week_offset="$1"
    [[ -z "$week_offset" ]] && week_offset='0'
    format='%m-%d'
    schedule_file="$HOME/todo.md"
    typeset -A classes
    assignments=`sed -n '/assignments/,/schedule/p' $PERSONAL/todo.md`
    class_nums=(561 572 598 'kgd')
    classes[561]=`echo "$assignments" | sed -n '/csci 561/,/csci 572/p' | head -n-1`
    classes[572]=`echo "$assignments" | sed -n '/csci 572/,/csci 598/p' | head -n-1`
    classes[598]=`echo "$assignments" | sed -n '/csci 598/,/kgd/p'   | head -n-1`
    classes[kgd]=`echo "$assignments" | sed -n '/kgd/,/schedule/p' | head -n-1`
    for k in $class_nums; do
        echo "\ncsci $k"
        echo "--------"
        let day="$week_offset*7"
        for i in {0..7}; do
            due_date="$(date --date="$day days" +$format)"
            let day="$day+1"
            echo "$classes[$k]" | grep --color=never "$due_date" | grep -v "DONE"
        done
    done
}

# default due function
# --------------------
alias due='due_week'


# current event
# -------------
tasks() {
    #event_offset=$1+1
    #[[ -z "$event_offset" ]] && event_offset=1
    schedule_file="$HOME/todo.md"
    curr_event="$(today 0 | grep '^-   ')"
    [[ -z "$curr_event" ]] && return 1
    curr_event=$(echo "$curr_event" | sed 's/.*\?-\([0-9:]\+\)/\1/')
    curr_time="$(date +'%H:%M') {NOW}"
    curr_event="$(echo "$curr_event\n$curr_time" | sort | grep -A1 "{NOW}" | tail -n1)"
    curr_event="$(echo "$curr_event" | sed 's/.*\?\s\{4\}\(.*\)/\1/' | awk '{print tolower($0)}')"
    sed -n '/^'"$curr_event"'$/,/^\w/p' $schedule_file | head -n -1
}

# next event
# ----------
next() {
    next_event="$(today 0 | grep '^-   ' | cut --characters=5-)"
    [[ -z "$next_event" ]] && return 1
    curr_time="$(date +'%H:%M') {NOW}"
    next_event="$(echo "$next_event\n$curr_time" | sort)"
    echo "$next_event" | grep -A1 "{NOW}" | tail -n1
}


# Source additional aliases
# =========================
[[ -n "$DISPLAY" ]] && source_alias 'x' > /dev/null
source_alias 'python' > /dev/null
source_alias 'cluster' > /dev/null
